
#ifndef _MATRIX_H_

#define _MATRIX_H_

#include "../Common.h"
#include <memory.h>
#include <math.h>

namespace Core
{

class Matrix4
{
	public:

		static Matrix4 Identity;
		static Matrix4 SphereMap;

		Matrix4() {};
		~Matrix4() {};

		Matrix4(const Matrix4& _m) { memcpy((void *)m,(void *)_m.m,16*sizeof(float)); };

		const Matrix4& operator=(const Matrix4& _m)
		{ memcpy((void *)m,(void *)_m.m,16*sizeof(float)); return *this; };

		Matrix4 operator*(const Matrix4& _m) const {
						Matrix4 temp;
						int i,j;

						for(i=0;i<4;i++)
							for(j=0;j<4;j++)
								temp.m[i][j]=m[i][0] * _m.m[0][j] +
											 m[i][1] * _m.m[1][j] +
											 m[i][2] * _m.m[2][j] +
											 m[i][3] * _m.m[3][j];

						return temp;
												};
		const Matrix4& operator*=(const Matrix4& _m) {
						Matrix4 temp;
						int i,j;

						for(i=0;i<4;i++)
							for(j=0;j<4;j++)
								temp.m[i][j]=m[i][0] * _m.m[0][j] +
											 m[i][1] * _m.m[1][j] +
											 m[i][2] * _m.m[2][j] +
											 m[i][3] * _m.m[3][j];

						*this=temp;
						return *this;
														};

		void CreateIdentity() {
						m[0][0]=1.0f; m[0][1]=0.0f; m[0][2]=0.0f; m[0][3]=0.0f;
						m[1][0]=0.0f; m[1][1]=1.0f; m[1][2]=0.0f; m[1][3]=0.0f;
						m[2][0]=0.0f; m[2][1]=0.0f; m[2][2]=1.0f; m[2][3]=0.0f;
						m[3][0]=0.0f; m[3][1]=0.0f; m[3][2]=0.0f; m[3][3]=1.0f;
								};
		void CreateTranslate(const float x,
							 const float y,
							 const float z) {
						m[0][0]=1.0f; m[0][1]=0.0f; m[0][2]=0.0f; m[0][3]=0.0f;
						m[1][0]=0.0f; m[1][1]=1.0f; m[1][2]=0.0f; m[1][3]=0.0f;
						m[2][0]=0.0f; m[2][1]=0.0f; m[2][2]=1.0f; m[2][3]=0.0f;
						m[3][0]=x   ; m[3][1]=y   ; m[3][2]=z   ; m[3][3]=1.0f;
											};
		void CreateScale(const float x,
						 const float y,
						 const float z) {
						m[0][0]=x   ; m[0][1]=0.0f; m[0][2]=0.0f; m[0][3]=0.0f;
						m[1][0]=0.0f; m[1][1]=y   ; m[1][2]=0.0f; m[1][3]=0.0f;
						m[2][0]=0.0f; m[2][1]=0.0f; m[2][2]=z   ; m[2][3]=0.0f;
						m[3][0]=0.0f; m[3][1]=0.0f; m[3][2]=0.0f; m[3][3]=1.0f;
										};
		
		void CreateRotateX(int x) {
						while(x >= 360)
							x-=360;

						while(x < 0)
							x+=360;

						const float c=TCos[x];
						const float s=TSin[x];

						m[0][0]=1.0f; m[0][1]=0.0f; m[0][2]=0.0f; m[0][3]=0.0f;
						m[1][0]=0.0f; m[1][1]=c;   m[1][2]=s;   m[1][3]=0.0f;
						m[2][0]=0.0f; m[2][1]=-s;  m[2][2]=c;   m[2][3]=0.0f;
						m[3][0]=0.0f; m[3][1]=0.0f; m[3][2]=0.0f; m[3][3]=1.0f;
										};
		void CreateRotateY(int y) {
						while(y >= 360)
							y-=360;

						while(y < 0)
							y+=360;

						const float c=TCos[y];
						const float s=TSin[y];

						m[0][0]=c;   m[0][1]=0.0f; m[0][2]=-s;  m[0][3]=0.0f;
						m[1][0]=0.0f; m[1][1]=1.0f; m[1][2]=0.0f; m[1][3]=0.0f;
						m[2][0]=s;   m[2][1]=0.0f; m[2][2]=c;   m[2][3]=0.0f;
						m[3][0]=0.0f; m[3][1]=0.0f; m[3][2]=0.0f; m[3][3]=1.0f;
									};
		void CreateRotateZ(int z) {
						while(z >= 360)
							z-=360;

						while(z < 0)
							z+=360;

						const float c=TCos[z];
						const float s=TSin[z];

						m[0][0]=c;   m[0][1]=s;   m[0][2]=0.0f; m[0][3]=0.0f;
						m[1][0]=-s;  m[1][1]=c;   m[1][2]=0.0f; m[1][3]=0.0f;
						m[2][0]=0.0f; m[2][1]=0.0f; m[2][2]=1.0f; m[2][3]=0.0f;
						m[3][0]=0.0f; m[3][1]=0.0f; m[3][2]=0.0f; m[3][3]=1.0f;
								};
		void CreateRotateXYZ(int x,
							 int y,
							 int z)
		{
			while(x < 0) x+=360;
			while(x >= 360) x-=360;
			while(y < 0) y+=360;
			while(y >= 360) y-=360;
			while(z < 0) z+=360;
			while(z >= 360) y-=360;

			const float cr=TCos[x], sr=TSin[x];
			const float cp=TCos[y], sp=TSin[y];
			const float cy=TCos[z], sy=TSin[z];
			const float srsp=sr*sp, crsp=cr*sp;

			m[0][0]=cp*cy; m[0][1]=cp*sy; m[0][2]=-sp; m[0][3]=0.0f;
			m[1][0]=srsp*cy-cr*sy;
			m[1][1]=srsp*sy+cr*cy;
			m[1][2]=sr*cp; m[1][3]=0.0f;

			m[2][0]=crsp*cy+sr*sy;
			m[2][1]=crsp*sy-sr*cy;
			m[2][2]=cr*cp; m[2][3]=0.0f;

			m[3][0]=m[3][1]=m[3][2]=0.0f; m[3][3]=1.0f;
		}

		bool Inverse(Matrix4& mat) const
		{
			float d=(m[0][0] * m[1][1] - m[1][0] * m[0][1]) * (m[2][2] * m[3][3] - m[3][2] * m[2][3]) - (m[0][0] * m[2][1] - m[2][0] * m[0][1]) * (m[1][2] * m[3][3] - m[3][2] * m[1][3]) +
					(m[0][0] * m[3][1] - m[3][0] * m[0][1]) * (m[1][2] * m[2][3] - m[2][2] * m[1][3]) + (m[1][0] * m[2][1] - m[2][0] * m[1][1]) * (m[0][2] * m[3][3] - m[3][2] * m[0][3]) -
					(m[1][0] * m[3][1] - m[3][0] * m[1][1]) * (m[0][2] * m[2][3] - m[2][2] * m[0][3]) + (m[2][0] * m[3][1] - m[3][0] * m[2][1]) * (m[0][2] * m[1][3] - m[1][2] * m[0][3]);

			if(d==0.0f)
				return false;

			d=1.0f / d;

			mat.m[0][0]=d * (m[1][1] * (m[2][2] * m[3][3] - m[3][2] * m[2][3]) + m[2][1] * (m[3][2] * m[1][3] - m[1][2] * m[3][3]) + m[3][1] * (m[1][2] * m[2][3] - m[2][2] * m[1][3]));
			mat.m[1][0]=d * (m[1][2] * (m[2][0] * m[3][3] - m[3][0] * m[2][3]) + m[2][2] * (m[3][0] * m[1][3] - m[1][0] * m[3][3]) + m[3][2] * (m[1][0] * m[2][3] - m[2][0] * m[1][3]));
			mat.m[2][0]=d * (m[1][3] * (m[2][0] * m[3][1] - m[3][0] * m[2][1]) + m[2][3] * (m[3][0] * m[1][1] - m[1][0] * m[3][1]) + m[3][3] * (m[1][0] * m[2][1] - m[2][0] * m[1][1]));
			mat.m[3][0]=d * (m[1][0] * (m[3][1] * m[2][2] - m[2][1] * m[3][2]) + m[2][0] * (m[1][1] * m[3][2] - m[3][1] * m[1][2]) + m[3][0] * (m[2][1] * m[1][2] - m[1][1] * m[2][2]));

			mat.m[0][1]=d * (m[2][1] * (m[0][2] * m[3][3] - m[3][2] * m[0][3]) + m[3][1] * (m[2][2] * m[0][3] - m[0][2] * m[2][3]) + m[0][1] * (m[3][2] * m[2][3] - m[2][2] * m[3][3]));
			mat.m[1][1]=d * (m[2][2] * (m[0][0] * m[3][3] - m[3][0] * m[0][3]) + m[3][2] * (m[2][0] * m[0][3] - m[0][0] * m[2][3]) + m[0][2] * (m[3][0] * m[2][3] - m[2][0] * m[3][3]));
			mat.m[2][1]=d * (m[2][3] * (m[0][0] * m[3][1] - m[3][0] * m[0][1]) + m[3][3] * (m[2][0] * m[0][1] - m[0][0] * m[2][1]) + m[0][3] * (m[3][0] * m[2][1] - m[2][0] * m[3][1]));
			mat.m[3][1]=d * (m[2][0] * (m[3][1] * m[0][2] - m[0][1] * m[3][2]) + m[3][0] * (m[0][1] * m[2][2] - m[2][1] * m[0][2]) + m[0][0] * (m[2][1] * m[3][2] - m[3][1] * m[2][2]));

			mat.m[0][2]=d * (m[3][1] * (m[0][2] * m[1][3] - m[1][2] * m[0][3]) + m[0][1] * (m[1][2] * m[3][3] - m[3][2] * m[1][3]) + m[1][1] * (m[3][2] * m[0][3] - m[0][2] * m[3][3]));
			mat.m[1][2]=d * (m[3][2] * (m[0][0] * m[1][3] - m[1][0] * m[0][3]) + m[0][2] * (m[1][0] * m[3][3] - m[3][0] * m[1][3]) + m[1][2] * (m[3][0] * m[0][3] - m[0][0] * m[3][3]));
			mat.m[2][2]=d * (m[3][3] * (m[0][0] * m[1][1] - m[1][0] * m[0][1]) + m[0][3] * (m[1][0] * m[3][1] - m[3][0] * m[1][1]) + m[1][3] * (m[3][0] * m[0][1] - m[0][0] * m[3][1]));
			mat.m[3][2]=d * (m[3][0] * (m[1][1] * m[0][2] - m[0][1] * m[1][2]) + m[0][0] * (m[3][1] * m[1][2] - m[1][1] * m[3][2]) + m[1][0] * (m[0][1] * m[3][2] - m[3][1] * m[0][2]));

			mat.m[0][3]=d * (m[0][1] * (m[2][2] * m[1][3] - m[1][2] * m[2][3]) + m[1][1] * (m[0][2] * m[2][3] - m[2][2] * m[0][3]) + m[2][1] * (m[1][2] * m[0][3] - m[0][2] * m[1][3]));
			mat.m[1][3]=d * (m[0][2] * (m[2][0] * m[1][3] - m[1][0] * m[2][3]) + m[1][2] * (m[0][0] * m[2][3] - m[2][0] * m[0][3]) + m[2][2] * (m[1][0] * m[0][3] - m[0][0] * m[1][3]));
			mat.m[2][3]=d * (m[0][3] * (m[2][0] * m[1][1] - m[1][0] * m[2][1]) + m[1][3] * (m[0][0] * m[2][1] - m[2][0] * m[0][1]) + m[2][3] * (m[1][0] * m[0][1] - m[0][0] * m[1][1]));
			mat.m[3][3]=d * (m[0][0] * (m[1][1] * m[2][2] - m[2][1] * m[1][2]) + m[1][0] * (m[2][1] * m[0][2] - m[0][1] * m[2][2]) + m[2][0] * (m[0][1] * m[1][2] - m[1][1] * m[0][2]));

			return true;
		}

		void Transpose(Matrix4& mat) const
		{
			mat.m[0][0]=m[0][0]; mat.m[0][1]=m[1][0]; mat.m[0][2]=m[2][0]; mat.m[0][3]=m[3][0];
			mat.m[1][0]=m[0][1]; mat.m[1][1]=m[1][1]; mat.m[1][2]=m[2][1]; mat.m[1][3]=m[3][1];
			mat.m[2][0]=m[0][2]; mat.m[2][1]=m[1][2]; mat.m[2][2]=m[2][2]; mat.m[2][3]=m[3][2];
			mat.m[3][0]=m[0][3]; mat.m[3][1]=m[1][3]; mat.m[3][2]=m[2][3]; mat.m[3][3]=m[3][3];
		}

		static void InitTrigo();

		float m[4][4];

		static float TCos[360];
		static float TSin[360];
};

}

#endif